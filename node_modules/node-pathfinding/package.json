{
  "name": "node-pathfinding",
  "version": "0.2.6",
  "description": "a Node.JS implementation for AStar path finding algorithm. This implementation uses primitive data types (Number and Byte/Buffer) to present location and block data that significantly improve the speed and have a good control on memory consumption",
  "homepage": "https://github.com/yi/node-path-finding",
  "keywords": [
    "algorithm",
    "game",
    "astar",
    "grid",
    "movement",
    "multiplayer",
    "pathfinding"
  ],
  "author": {
    "name": "yi",
    "email": "yi2004@gmail.com",
    "url": "https://github.com/yi"
  },
  "main": "./index.js",
  "dependencies": {},
  "devDependencies": {
    "memwatch": ">=0"
  },
  "engines": {
    "node": ">=0.8.0"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com/yi/node-path-finding.git"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "http://opensource.org/licenses/mit-license.php"
    }
  ],
  "readmeFilename": "README.md",
  "scripts": {
    "test": "node tests/sync_astar_continue_test.js "
  },
  "license": "MIT",
  "readme": "# Node Path Finding\n\nThis is a Node.JS implementation for AStar path finding algorithm.\nThis implementation uses primitive data types (Number and Byte/Buffer) to present location and block data that significantly improve the speed and have a good control on memory consumption\n\n## Installation\n\n```bash\nnpm install node-pathfinding\n```\n\n## Advantages\n- This module uses much less runtime memory then other node path finding module I can find on the net\n- The path finding implementation uses primative JavaScript Number type, so much safe to memory leak\n- Simple code, easy to change and extend\n\n## Limitations\n- The max size of map is limited to 65535 x 65535\n- Does not support negtive location\n\n## How To Use\n\n```javascript\nvar array2d, buf, grid, height, path, pathfinding, width;\n\npathfinding = require(\"node-pathfinding\");\n\narray2d = [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [1, 1, 0, 0], [1, 0, 0, 0]];\n\nwidth = 4;\n\nheight = 5;\n\n// generate grid from 2D array\nbuf = pathfinding.bytesFrom2DArray(width, height, array2d);\ngrid = pathfinding.buildGrid(width, height, buf);\n\npath = pathfinding.findPath(1, 0, 1, 4, grid);\n\nconsole.log(\"path:\" + path);\n\n// print the path\nconsole.log(\"path on grid :\" + (grid.toString(1 << 16 | 0, 1 << 16 | 4, path)));\n\n// output:\n// path:65536,131072,131073,196609,196610,196611,196612,131076,65540\n// path on grid :[Grid(width=4, height=5)]\n// Dump: ░=walkable, ▓=blocked\n// ▓S1░\n// ░▓23\n// ░░▓4\n// ▓▓░5\n// ▓E76\n\n```\n\n## Glossary\n- BrickLoc: To reduce memory usage and use less Object instances, each dot(node, point) in the given map is represented by an 32bit uint, which is composed by ` x << 16 | y `\n- Map Buffer: The map is presented by a Buffer, column by row. Each dot(node, point) is a bit in the Buffer. 0 means walkable, 1 means blocked.\n\n## Performance and Memory Consumption\n\nTry ```node tests/sync_astar_continue_test.js```\nit does a continuous test of pathfinding on some map fixtures, and the vm memory recycled correctly.\n\n\n\n",
  "_id": "node-pathfinding@0.2.6",
  "dist": {
    "shasum": "6f93bf17e38f54c335d7a5769396aedac6846e33",
    "tarball": "http://registry.npmjs.org/node-pathfinding/-/node-pathfinding-0.2.6.tgz"
  },
  "_from": "node-pathfinding@*",
  "_npmVersion": "1.2.10",
  "_npmUser": {
    "name": "yi",
    "email": "yi2004@gmail.com"
  },
  "maintainers": [
    {
      "name": "yi",
      "email": "yi2004@gmail.com"
    }
  ],
  "directories": {},
  "_shasum": "6f93bf17e38f54c335d7a5769396aedac6846e33",
  "_resolved": "http://registry.npmjs.org/node-pathfinding/-/node-pathfinding-0.2.6.tgz"
}
